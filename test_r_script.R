#!/usr/bin/env Rscript

# Test script to read GCTA GRM files generated by our Rust dgrm tool
# Based on the provided read_first100_grm.R script

# Config
prefix <- "test_grm"  # Use our test files
float_size <- 4  # 4 bytes float

cat("=== Testing R script compatibility with dgrm output ===\n")

# Read ID file
cat("Reading ID file...\n")
id <- read.table(paste0(prefix, ".grm.id"), header = FALSE, stringsAsFactors = FALSE)
n <- nrow(id)
cat("Found", n, "samples\n")

# For test: read first m samples (up to 100, or all if fewer)
m <- min(10L, n)  # Use 10 for our test data
cat("Processing first", m, "samples\n")

# Calculate number of elements needed (upper triangular with diagonal)
n_pairs <- m * (m + 1L) / 2L
cat("Expected number of elements:", n_pairs, "\n")

# Read GRM binary file
cat("Reading GRM binary file...\n")
con_grm <- file(paste0(prefix, ".grm.bin"), "rb")
grm_vec <- readBin(con_grm, what = numeric(), n = n_pairs, size = float_size)
close(con_grm)
cat("Read", length(grm_vec), "GRM values\n")

# Read N binary file
cat("Reading N binary file...\n")
con_N <- file(paste0(prefix, ".grm.N.bin"), "rb")
# Read a large number of elements to get all available
all_N <- readBin(con_N, what = numeric(), n = 100000, size = float_size)
close(con_N)
cat("Found", length(all_N), "N values in file\n")

# Check if we need to subset or if there's one value per element
if (length(all_N) == 1L) {
    # Single value case - replicate
    N_vec <- rep(all_N, n_pairs)
    cat("Using single N value:", all_N, "for all elements\n")
} else if (length(all_N) >= n_pairs) {
    # Multiple values - take first n_pairs
    N_vec <- all_N[1:n_pairs]
    cat("Using first", n_pairs, "N values\n")
} else {
    stop("N file has fewer values than expected")
}

# Build (i, j) index pairs in GCTA order: for i in 1..m, j in 1..i
pairs <- do.call(rbind, lapply(1:m, function(i) cbind(i = rep.int(i, i), j = 1:i)))
cat("Generated", nrow(pairs), "index pairs\n")

# Check that we have the right number of values
if (length(grm_vec) != nrow(pairs)) {
    stop("Mismatch: expected ", nrow(pairs), " GRM values, got ", length(grm_vec))
}

# Reconstruct lower-triangular GRM matrix (upper triangle left blank)
G <- matrix(NA_real_, nrow = m, ncol = m)
G[cbind(pairs[, 1], pairs[, 2])] <- grm_vec

# Label rows/cols with "FID_IID" format
labels <- paste(id[1:m, 1], id[1:m, 2], sep = "_")
rownames(G) <- labels
colnames(G) <- labels

cat("=== GRM Matrix (first 5x5) ===\n")
print(G[1:min(5, m), 1:min(5, m)])

cat("\n=== Statistics ===\n")
cat("Diagonal elements (should be ~1.0):\n")
print(diag(G))

cat("\nOff-diagonal range:\n")
off_diag <- G[lower.tri(G)]
cat("Min:", min(off_diag, na.rm = TRUE), "\n")
cat("Max:", max(off_diag, na.rm = TRUE), "\n")
cat("Mean:", mean(off_diag, na.rm = TRUE), "\n")

cat("\n=== SUCCESS: R script can read dgrm output correctly ===\n")