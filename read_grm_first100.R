# read_grm_first100.R
# Read GRM files generated by dgrm and export first K samples as lower-triangular matrix
#
# Args: prefix (without extension), K (default 100), out_txt path

read_grm_first_k <- function(prefix, K = 100, out_txt = NULL) {
  id_path  <- paste0(prefix, ".grm.id")
  bin_path <- paste0(prefix, ".grm.bin")
  n_path   <- paste0(prefix, ".grm.N.bin")

  # Check if files exist
  if (!file.exists(id_path)) {
    stop("ID file not found: ", id_path)
  }
  if (!file.exists(bin_path)) {
    stop("GRM binary file not found: ", bin_path)
  }
  if (!file.exists(n_path)) {
    stop("N binary file not found: ", n_path)
  }

  # Read sample IDs
  ids <- read.table(id_path, header = FALSE, stringsAsFactors = FALSE)
  # GCTA .grm.id is FID IID; use IID (2nd col) if present, otherwise 1st col
  if (ncol(ids) >= 2) {
    samp <- ids[[2]]
  } else {
    samp <- ids[[1]]
  }
  n <- length(samp)
  K <- min(K, n)
  
  cat("Found", n, "samples, reading first", K, "samples\n")
  
  # Calculate number of elements in lower triangular matrix
  idx_len <- K * (K + 1) / 2

  # Read GRM values (4-byte floats, little endian)
  con_bin <- file(bin_path, "rb")
  on.exit(close(con_bin), add = TRUE)
  vals <- readBin(con_bin, what = "numeric", n = idx_len, size = 4, endian = "little")

  # Read N values (4-byte floats, little endian)
  con_n <- file(n_path, "rb")
  on.exit(close(con_n), add = TRUE)
  Ns <- readBin(con_n, what = "numeric", n = idx_len, size = 4, endian = "little")

  # Fill K x K lower-triangular matrix (row-major order)
  # Initialize with NA for upper triangle
  mat <- matrix(NA_real_, nrow = K, ncol = K)
  matN <- matrix(NA_real_, nrow = K, ncol = K)
  
  pos <- 1L
  for (j in 1:K) {
    for (k in 1:j) {
      mat[j, k]  <- vals[pos]
      matN[j, k] <- Ns[pos]
      pos <- pos + 1L
    }
  }
  
  # Set row and column names
  rownames(mat) <- samp[1:K]
  colnames(mat) <- samp[1:K]
  rownames(matN) <- samp[1:K]
  colnames(matN) <- samp[1:K]

  # Set output file name
  if (is.null(out_txt)) {
    out_txt <- paste0(prefix, ".first", K, ".lower.txt")
  }
  
  # Write lower-triangular GRM matrix to file
  write.table(mat, file = out_txt, sep = "\t", quote = FALSE, col.names = NA)

  # Also write N matrix
  n_out_txt <- gsub("\\.txt$", ".N.txt", out_txt)
  write.table(matN, file = n_out_txt, sep = "\t", quote = FALSE, col.names = NA)

  cat("Wrote lower-triangular GRM (", K, "x", K, ") to", out_txt, "\n")
  cat("Wrote lower-triangular N matrix (", K, "x", K, ") to", n_out_txt, "\n")
  
  invisible(list(GRM = mat, N = matN, IDs = samp[1:K]))
}

# Read GRM submatrix for the first K IDs listed in an external .grm.id file
# (use the IID column if present), by random-access reading from the full GRM.
# Exports a full symmetric K x K matrix and the corresponding N matrix.
read_grm_by_ids <- function(prefix, id_selector_path, K = 100, out_txt = NULL) {
  id_path  <- paste0(prefix, ".grm.id")
  bin_path <- paste0(prefix, ".grm.bin")
  n_path   <- paste0(prefix, ".grm.N.bin")

  if (!file.exists(id_path))  stop("ID file not found: ", id_path)
  if (!file.exists(bin_path)) stop("GRM binary file not found: ", bin_path)
  if (!file.exists(n_path))   stop("N binary file not found: ", n_path)
  if (!file.exists(id_selector_path)) stop("Selector ID file not found: ", id_selector_path)

  # Read GRM sample IDs (order defines matrix indexing)
  ids <- read.table(id_path, header = FALSE, stringsAsFactors = FALSE)
  samp <- if (ncol(ids) >= 2) ids[[2]] else ids[[1]]
  n <- length(samp)

  # Read selector IDs and take first K
  sel_ids_tbl <- read.table(id_selector_path, header = FALSE, stringsAsFactors = FALSE)
  sel_all <- if (ncol(sel_ids_tbl) >= 2) sel_ids_tbl[[2]] else sel_ids_tbl[[1]]
  K <- min(as.integer(K), length(sel_all))
  sel_ids <- sel_all[seq_len(K)]

  # Map selector IDs to indices in the GRM
  sel_idx <- match(sel_ids, samp)
  if (any(is.na(sel_idx))) {
    missing <- sel_ids[is.na(sel_idx)]
    stop("The following IDs from selector are not found in GRM: ", paste(missing, collapse = ", "))
  }

  cat("Found", n, "samples in GRM; extracting submatrix for", K, "IDs from selector file\n")

  # Helpers: position in row-major lower-triangular vector (1-based), then byte offset
  tri_pos <- function(i, j) {
    # Ensure i >= j
    if (j > i) {
      tmp <- i; i <- j; j <- tmp
    }
    as.double((i - 1) * i / 2 + j)
  }

  to_bytes <- function(pos) {
    # 4-byte float, zero-based offset
    as.double((pos - 1) * 4)
  }

  # Open binary connections once
  con_bin <- file(bin_path, "rb")
  on.exit(close(con_bin), add = TRUE)
  con_n <- file(n_path, "rb")
  on.exit(close(con_n), add = TRUE)

  # Allocate full symmetric matrices
  mat <- matrix(NA_real_, nrow = K, ncol = K)
  matN <- matrix(NA_real_, nrow = K, ncol = K)

  for (a in seq_len(K)) {
    for (b in seq_len(a)) {
      i <- sel_idx[a]
      j <- sel_idx[b]
      p <- tri_pos(i, j)
      off <- to_bytes(p)

      seek(con_bin, where = off, origin = "start")
      val <- readBin(con_bin, what = "numeric", n = 1, size = 4, endian = "little")
      seek(con_n, where = off, origin = "start")
      nval <- readBin(con_n, what = "numeric", n = 1, size = 4, endian = "little")

      mat[a, b] <- val
      mat[b, a] <- val
      matN[a, b] <- nval
      matN[b, a] <- nval
    }
  }

  rownames(mat) <- sel_ids
  colnames(mat) <- sel_ids
  rownames(matN) <- sel_ids
  colnames(matN) <- sel_ids

  if (is.null(out_txt)) {
    out_txt <- paste0(prefix, ".selector_first", K, ".full.txt")
  }

  write.table(mat, file = out_txt, sep = "\t", quote = FALSE, col.names = NA)
  n_out_txt <- gsub("\\.txt$", ".N.txt", out_txt)
  write.table(matN, file = n_out_txt, sep = "\t", quote = FALSE, col.names = NA)

  cat("Wrote symmetric GRM (", K, "x", K, ") to", out_txt, "\n")
  cat("Wrote symmetric N matrix (", K, "x", K, ") to", n_out_txt, "\n")

  invisible(list(GRM = mat, N = matN, IDs = sel_ids))
}

# Convenience wrapper for command line usage
if (!interactive()) {
  args <- commandArgs(trailingOnly = TRUE)
  if (length(args) < 1) {
    cat("Usage: Rscript read_grm_first100.R <prefix> [id_selector.grm.id] [K] [output.txt]\n")
    cat("  prefix: GRM file prefix (without .grm.bin extension)\n")
    cat("  id_selector.grm.id: optional path to a .grm.id file; take its first K IDs to extract submatrix\n")
    cat("  K: number of samples to read (default: 100)\n")
    cat("  output.txt: output file path (optional)\n")
    quit(status = 1)
  }

  prefix <- args[1]
  id_selector <- NULL
  K <- 100
  out_txt <- NULL

  arg_idx <- 2
  if (length(args) >= arg_idx && file.exists(args[arg_idx])) {
    id_selector <- args[arg_idx]
    arg_idx <- arg_idx + 1
  }
  if (length(args) >= arg_idx) {
    k_try <- suppressWarnings(as.numeric(args[arg_idx]))
    if (!is.na(k_try)) {
      K <- as.integer(k_try)
      arg_idx <- arg_idx + 1
    }
  }
  if (length(args) >= arg_idx) {
    out_txt <- args[arg_idx]
  }

  if (!is.null(id_selector)) {
    read_grm_by_ids(prefix, id_selector, K, out_txt)
  } else {
    read_grm_first_k(prefix, K, out_txt)
  }
}

# Example usage in R:
# read_grm_first_k("path/to/output_prefix", 100, "first100_grm.txt")
#
# From command line:
# Rscript read_grm_first100.R path/to/output_prefix 100 first100_grm.txt